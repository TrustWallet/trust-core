// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: core/Tron.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Protocol_AccountType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case normal // = 0
  case assetIssue // = 1
  case contract // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .normal
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .normal
    case 1: self = .assetIssue
    case 2: self = .contract
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .normal: return 0
    case .assetIssue: return 1
    case .contract: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Protocol_AccountType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Protocol_AccountType] = [
    .normal,
    .assetIssue,
    .contract,
  ]
}

#endif  // swift(>=4.2)

enum Protocol_ReasonCode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case requested // = 0
  case badProtocol // = 2
  case tooManyPeers // = 4
  case duplicatePeer // = 5
  case incompatibleProtocol // = 6
  case nullIdentity // = 7
  case peerQuiting // = 8
  case unexpectedIdentity // = 9
  case localIdentity // = 10
  case pingTimeout // = 11
  case userReason // = 16
  case reset // = 17
  case syncFail // = 18
  case fetchFail // = 19
  case badTx // = 20
  case badBlock // = 21
  case forked // = 22
  case unlinkable // = 23
  case incompatibleVersion // = 24
  case incompatibleChain // = 25
  case timeOut // = 32
  case connectFail // = 33
  case tooManyPeersWithSameIp // = 34
  case unknown // = 255
  case UNRECOGNIZED(Int)

  init() {
    self = .requested
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .requested
    case 2: self = .badProtocol
    case 4: self = .tooManyPeers
    case 5: self = .duplicatePeer
    case 6: self = .incompatibleProtocol
    case 7: self = .nullIdentity
    case 8: self = .peerQuiting
    case 9: self = .unexpectedIdentity
    case 10: self = .localIdentity
    case 11: self = .pingTimeout
    case 16: self = .userReason
    case 17: self = .reset
    case 18: self = .syncFail
    case 19: self = .fetchFail
    case 20: self = .badTx
    case 21: self = .badBlock
    case 22: self = .forked
    case 23: self = .unlinkable
    case 24: self = .incompatibleVersion
    case 25: self = .incompatibleChain
    case 32: self = .timeOut
    case 33: self = .connectFail
    case 34: self = .tooManyPeersWithSameIp
    case 255: self = .unknown
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .requested: return 0
    case .badProtocol: return 2
    case .tooManyPeers: return 4
    case .duplicatePeer: return 5
    case .incompatibleProtocol: return 6
    case .nullIdentity: return 7
    case .peerQuiting: return 8
    case .unexpectedIdentity: return 9
    case .localIdentity: return 10
    case .pingTimeout: return 11
    case .userReason: return 16
    case .reset: return 17
    case .syncFail: return 18
    case .fetchFail: return 19
    case .badTx: return 20
    case .badBlock: return 21
    case .forked: return 22
    case .unlinkable: return 23
    case .incompatibleVersion: return 24
    case .incompatibleChain: return 25
    case .timeOut: return 32
    case .connectFail: return 33
    case .tooManyPeersWithSameIp: return 34
    case .unknown: return 255
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Protocol_ReasonCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Protocol_ReasonCode] = [
    .requested,
    .badProtocol,
    .tooManyPeers,
    .duplicatePeer,
    .incompatibleProtocol,
    .nullIdentity,
    .peerQuiting,
    .unexpectedIdentity,
    .localIdentity,
    .pingTimeout,
    .userReason,
    .reset,
    .syncFail,
    .fetchFail,
    .badTx,
    .badBlock,
    .forked,
    .unlinkable,
    .incompatibleVersion,
    .incompatibleChain,
    .timeOut,
    .connectFail,
    .tooManyPeersWithSameIp,
    .unknown,
  ]
}

#endif  // swift(>=4.2)

/// AccountId, (name, address) use name, (null, address) use address, (name, null) use name,
struct Protocol_AccountId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: Data = SwiftProtobuf.Internal.emptyData

  var address: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// vote message
struct Protocol_Vote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the super rep address
  var voteAddress: Data = SwiftProtobuf.Internal.emptyData

  /// the vote num to this super rep.
  var voteCount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Proposal
struct Protocol_Proposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var proposalID: Int64 = 0

  var proposerAddress: Data = SwiftProtobuf.Internal.emptyData

  var parameters: Dictionary<Int64,Int64> = [:]

  var expirationTime: Int64 = 0

  var createTime: Int64 = 0

  var approvals: [Data] = []

  var state: Protocol_Proposal.State = .pending

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum State: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case pending // = 0
    case disapproved // = 1
    case approved // = 2
    case canceled // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .pending
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .pending
      case 1: self = .disapproved
      case 2: self = .approved
      case 3: self = .canceled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .pending: return 0
      case .disapproved: return 1
      case .approved: return 2
      case .canceled: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Protocol_Proposal.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Protocol_Proposal.State] = [
    .pending,
    .disapproved,
    .approved,
    .canceled,
  ]
}

#endif  // swift(>=4.2)

/// Exchange
struct Protocol_Exchange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var exchangeID: Int64 = 0

  var creatorAddress: Data = SwiftProtobuf.Internal.emptyData

  var createTime: Int64 = 0

  var firstTokenID: Data = SwiftProtobuf.Internal.emptyData

  var firstTokenBalance: Int64 = 0

  var secondTokenID: Data = SwiftProtobuf.Internal.emptyData

  var secondTokenBalance: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_ChainParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chainParameter: [Protocol_ChainParameters.ChainParameter] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ChainParameter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var key: String = String()

    var value: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Account 
struct Protocol_Account {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// account nick name
  var accountName: Data {
    get {return _storage._accountName}
    set {_uniqueStorage()._accountName = newValue}
  }

  var type: Protocol_AccountType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// the create address
  var address: Data {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// the trx balance
  var balance: Int64 {
    get {return _storage._balance}
    set {_uniqueStorage()._balance = newValue}
  }

  /// the votes
  var votes: [Protocol_Vote] {
    get {return _storage._votes}
    set {_uniqueStorage()._votes = newValue}
  }

  /// the other asset owned by this account
  var asset: Dictionary<String,Int64> {
    get {return _storage._asset}
    set {_uniqueStorage()._asset = newValue}
  }

  /// the frozen balance
  var frozen: [Protocol_Account.Frozen] {
    get {return _storage._frozen}
    set {_uniqueStorage()._frozen = newValue}
  }

  /// bandwidth, get from frozen
  var netUsage: Int64 {
    get {return _storage._netUsage}
    set {_uniqueStorage()._netUsage = newValue}
  }

  /// this account create time
  var createTime: Int64 {
    get {return _storage._createTime}
    set {_uniqueStorage()._createTime = newValue}
  }

  /// this last operation time, including transfer, voting and so on. //FIXME fix grammar
  var latestOprationTime: Int64 {
    get {return _storage._latestOprationTime}
    set {_uniqueStorage()._latestOprationTime = newValue}
  }

  /// witness block producing allowance
  var allowance: Int64 {
    get {return _storage._allowance}
    set {_uniqueStorage()._allowance = newValue}
  }

  /// last withdraw time
  var latestWithdrawTime: Int64 {
    get {return _storage._latestWithdrawTime}
    set {_uniqueStorage()._latestWithdrawTime = newValue}
  }

  /// not used so far
  var code: Data {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  var isWitness: Bool {
    get {return _storage._isWitness}
    set {_uniqueStorage()._isWitness = newValue}
  }

  var isCommittee: Bool {
    get {return _storage._isCommittee}
    set {_uniqueStorage()._isCommittee = newValue}
  }

  /// frozen asset(for asset issuer)
  var frozenSupply: [Protocol_Account.Frozen] {
    get {return _storage._frozenSupply}
    set {_uniqueStorage()._frozenSupply = newValue}
  }

  /// asset_issued_name
  var assetIssuedName: Data {
    get {return _storage._assetIssuedName}
    set {_uniqueStorage()._assetIssuedName = newValue}
  }

  var latestAssetOperationTime: Dictionary<String,Int64> {
    get {return _storage._latestAssetOperationTime}
    set {_uniqueStorage()._latestAssetOperationTime = newValue}
  }

  var freeNetUsage: Int64 {
    get {return _storage._freeNetUsage}
    set {_uniqueStorage()._freeNetUsage = newValue}
  }

  var freeAssetNetUsage: Dictionary<String,Int64> {
    get {return _storage._freeAssetNetUsage}
    set {_uniqueStorage()._freeAssetNetUsage = newValue}
  }

  var latestConsumeTime: Int64 {
    get {return _storage._latestConsumeTime}
    set {_uniqueStorage()._latestConsumeTime = newValue}
  }

  var latestConsumeFreeTime: Int64 {
    get {return _storage._latestConsumeFreeTime}
    set {_uniqueStorage()._latestConsumeFreeTime = newValue}
  }

  /// the identity of this account, case insensitive
  var accountID: Data {
    get {return _storage._accountID}
    set {_uniqueStorage()._accountID = newValue}
  }

  var accountResource: Protocol_Account.AccountResource {
    get {return _storage._accountResource ?? Protocol_Account.AccountResource()}
    set {_uniqueStorage()._accountResource = newValue}
  }
  /// Returns true if `accountResource` has been explicitly set.
  var hasAccountResource: Bool {return _storage._accountResource != nil}
  /// Clears the value of `accountResource`. Subsequent reads from it will return its default value.
  mutating func clearAccountResource() {_uniqueStorage()._accountResource = nil}

  var codeHash: Data {
    get {return _storage._codeHash}
    set {_uniqueStorage()._codeHash = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// frozen balance 
  struct Frozen {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the frozen trx balance
    var frozenBalance: Int64 = 0

    /// the expire time
    var expireTime: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct AccountResource {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// energy resource, get from frozen
    var energyUsage: Int64 {
      get {return _storage._energyUsage}
      set {_uniqueStorage()._energyUsage = newValue}
    }

    /// the frozen balance for energy
    var frozenBalanceForEnergy: Protocol_Account.Frozen {
      get {return _storage._frozenBalanceForEnergy ?? Protocol_Account.Frozen()}
      set {_uniqueStorage()._frozenBalanceForEnergy = newValue}
    }
    /// Returns true if `frozenBalanceForEnergy` has been explicitly set.
    var hasFrozenBalanceForEnergy: Bool {return _storage._frozenBalanceForEnergy != nil}
    /// Clears the value of `frozenBalanceForEnergy`. Subsequent reads from it will return its default value.
    mutating func clearFrozenBalanceForEnergy() {_uniqueStorage()._frozenBalanceForEnergy = nil}

    var latestConsumeTimeForEnergy: Int64 {
      get {return _storage._latestConsumeTimeForEnergy}
      set {_uniqueStorage()._latestConsumeTimeForEnergy = newValue}
    }

    /// storage resource, get from market
    var storageLimit: Int64 {
      get {return _storage._storageLimit}
      set {_uniqueStorage()._storageLimit = newValue}
    }

    var storageUsage: Int64 {
      get {return _storage._storageUsage}
      set {_uniqueStorage()._storageUsage = newValue}
    }

    var latestExchangeStorageTime: Int64 {
      get {return _storage._latestExchangeStorageTime}
      set {_uniqueStorage()._latestExchangeStorageTime = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Protocol_authority {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var account: Protocol_AccountId {
    get {return _storage._account ?? Protocol_AccountId()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {_uniqueStorage()._account = nil}

  var permissionName: Data {
    get {return _storage._permissionName}
    set {_uniqueStorage()._permissionName = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Protocol_permission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var account: Protocol_AccountId {
    get {return _storage._account ?? Protocol_AccountId()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  mutating func clearAccount() {_uniqueStorage()._account = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Witness
struct Protocol_Witness {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: Data = SwiftProtobuf.Internal.emptyData

  var voteCount: Int64 = 0

  var pubKey: Data = SwiftProtobuf.Internal.emptyData

  var url: String = String()

  var totalProduced: Int64 = 0

  var totalMissed: Int64 = 0

  var latestBlockNum: Int64 = 0

  var latestSlotNum: Int64 = 0

  var isJobs: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Vote Change
struct Protocol_Votes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: Data = SwiftProtobuf.Internal.emptyData

  var oldVotes: [Protocol_Vote] = []

  var newVotes: [Protocol_Vote] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_TXOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Int64 = 0

  var pubKeyHash: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_TXInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rawData: Protocol_TXInput.raw {
    get {return _storage._rawData ?? Protocol_TXInput.raw()}
    set {_uniqueStorage()._rawData = newValue}
  }
  /// Returns true if `rawData` has been explicitly set.
  var hasRawData: Bool {return _storage._rawData != nil}
  /// Clears the value of `rawData`. Subsequent reads from it will return its default value.
  mutating func clearRawData() {_uniqueStorage()._rawData = nil}

  var signature: Data {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct raw {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var txID: Data = SwiftProtobuf.Internal.emptyData

    var vout: Int64 = 0

    var pubKey: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Protocol_TXOutputs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var outputs: [Protocol_TXOutput] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_ResourceReceipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var energyUsage: Int64 = 0

  var energyFee: Int64 = 0

  var originEnergyUsage: Int64 = 0

  var energyUsageTotal: Int64 = 0

  var netUsage: Int64 = 0

  var netFee: Int64 = 0

  var result: Protocol_Transaction.Result.contractResult = .default

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rawData: Protocol_Transaction.raw {
    get {return _storage._rawData ?? Protocol_Transaction.raw()}
    set {_uniqueStorage()._rawData = newValue}
  }
  /// Returns true if `rawData` has been explicitly set.
  var hasRawData: Bool {return _storage._rawData != nil}
  /// Clears the value of `rawData`. Subsequent reads from it will return its default value.
  mutating func clearRawData() {_uniqueStorage()._rawData = nil}

  /// only support size = 1,  repeated list here for muti-sig extension
  var signature: [Data] {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  var ret: [Protocol_Transaction.Result] {
    get {return _storage._ret}
    set {_uniqueStorage()._ret = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Contract {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: Protocol_Transaction.Contract.ContractType {
      get {return _storage._type}
      set {_uniqueStorage()._type = newValue}
    }

    var parameter: SwiftProtobuf.Google_Protobuf_Any {
      get {return _storage._parameter ?? SwiftProtobuf.Google_Protobuf_Any()}
      set {_uniqueStorage()._parameter = newValue}
    }
    /// Returns true if `parameter` has been explicitly set.
    var hasParameter: Bool {return _storage._parameter != nil}
    /// Clears the value of `parameter`. Subsequent reads from it will return its default value.
    mutating func clearParameter() {_uniqueStorage()._parameter = nil}

    var provider: Data {
      get {return _storage._provider}
      set {_uniqueStorage()._provider = newValue}
    }

    var contractName: Data {
      get {return _storage._contractName}
      set {_uniqueStorage()._contractName = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum ContractType: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case accountCreateContract // = 0
      case transferContract // = 1
      case transferAssetContract // = 2
      case voteAssetContract // = 3
      case voteWitnessContract // = 4
      case witnessCreateContract // = 5
      case assetIssueContract // = 6
      case witnessUpdateContract // = 8
      case participateAssetIssueContract // = 9
      case accountUpdateContract // = 10
      case freezeBalanceContract // = 11
      case unfreezeBalanceContract // = 12
      case withdrawBalanceContract // = 13
      case unfreezeAssetContract // = 14
      case updateAssetContract // = 15
      case proposalCreateContract // = 16
      case proposalApproveContract // = 17
      case proposalDeleteContract // = 18
      case setAccountIDContract // = 19
      case customContract // = 20

      /// BuyStorageContract = 21;
      /// BuyStorageBytesContract = 22;
      /// SellStorageContract = 23;
      case createSmartContract // = 30
      case triggerSmartContract // = 31
      case getContract // = 32
      case updateSettingContract // = 33
      case exchangeCreateContract // = 41
      case exchangeInjectContract // = 42
      case exchangeWithdrawContract // = 43
      case exchangeTransactionContract // = 44
      case UNRECOGNIZED(Int)

      init() {
        self = .accountCreateContract
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .accountCreateContract
        case 1: self = .transferContract
        case 2: self = .transferAssetContract
        case 3: self = .voteAssetContract
        case 4: self = .voteWitnessContract
        case 5: self = .witnessCreateContract
        case 6: self = .assetIssueContract
        case 8: self = .witnessUpdateContract
        case 9: self = .participateAssetIssueContract
        case 10: self = .accountUpdateContract
        case 11: self = .freezeBalanceContract
        case 12: self = .unfreezeBalanceContract
        case 13: self = .withdrawBalanceContract
        case 14: self = .unfreezeAssetContract
        case 15: self = .updateAssetContract
        case 16: self = .proposalCreateContract
        case 17: self = .proposalApproveContract
        case 18: self = .proposalDeleteContract
        case 19: self = .setAccountIDContract
        case 20: self = .customContract
        case 30: self = .createSmartContract
        case 31: self = .triggerSmartContract
        case 32: self = .getContract
        case 33: self = .updateSettingContract
        case 41: self = .exchangeCreateContract
        case 42: self = .exchangeInjectContract
        case 43: self = .exchangeWithdrawContract
        case 44: self = .exchangeTransactionContract
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .accountCreateContract: return 0
        case .transferContract: return 1
        case .transferAssetContract: return 2
        case .voteAssetContract: return 3
        case .voteWitnessContract: return 4
        case .witnessCreateContract: return 5
        case .assetIssueContract: return 6
        case .witnessUpdateContract: return 8
        case .participateAssetIssueContract: return 9
        case .accountUpdateContract: return 10
        case .freezeBalanceContract: return 11
        case .unfreezeBalanceContract: return 12
        case .withdrawBalanceContract: return 13
        case .unfreezeAssetContract: return 14
        case .updateAssetContract: return 15
        case .proposalCreateContract: return 16
        case .proposalApproveContract: return 17
        case .proposalDeleteContract: return 18
        case .setAccountIDContract: return 19
        case .customContract: return 20
        case .createSmartContract: return 30
        case .triggerSmartContract: return 31
        case .getContract: return 32
        case .updateSettingContract: return 33
        case .exchangeCreateContract: return 41
        case .exchangeInjectContract: return 42
        case .exchangeWithdrawContract: return 43
        case .exchangeTransactionContract: return 44
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Result {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var fee: Int64 = 0

    var ret: Protocol_Transaction.Result.code = .sucess

    var contractRet: Protocol_Transaction.Result.contractResult = .default

    var withdrawAmount: Int64 = 0

    var unfreezeAmount: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum code: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case sucess // = 0
      case failed // = 1
      case UNRECOGNIZED(Int)

      init() {
        self = .sucess
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .sucess
        case 1: self = .failed
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .sucess: return 0
        case .failed: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    enum contractResult: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case `default` // = 0
      case success // = 1
      case revert // = 2
      case badJumpDestination // = 3
      case outOfMemory // = 4
      case precompiledContract // = 5
      case stackTooSmall // = 6
      case stackTooLarge // = 7
      case illegalOperation // = 8
      case stackOverflow // = 9
      case outOfEnergy // = 10
      case outOfTime // = 11
      case jvmStackOverFlow // = 12
      case unknown // = 13
      case UNRECOGNIZED(Int)

      init() {
        self = .default
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .default
        case 1: self = .success
        case 2: self = .revert
        case 3: self = .badJumpDestination
        case 4: self = .outOfMemory
        case 5: self = .precompiledContract
        case 6: self = .stackTooSmall
        case 7: self = .stackTooLarge
        case 8: self = .illegalOperation
        case 9: self = .stackOverflow
        case 10: self = .outOfEnergy
        case 11: self = .outOfTime
        case 12: self = .jvmStackOverFlow
        case 13: self = .unknown
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .default: return 0
        case .success: return 1
        case .revert: return 2
        case .badJumpDestination: return 3
        case .outOfMemory: return 4
        case .precompiledContract: return 5
        case .stackTooSmall: return 6
        case .stackTooLarge: return 7
        case .illegalOperation: return 8
        case .stackOverflow: return 9
        case .outOfEnergy: return 10
        case .outOfTime: return 11
        case .jvmStackOverFlow: return 12
        case .unknown: return 13
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  struct raw {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var refBlockBytes: Data = SwiftProtobuf.Internal.emptyData

    var refBlockNum: Int64 = 0

    var refBlockHash: Data = SwiftProtobuf.Internal.emptyData

    var expiration: Int64 = 0

    var auths: [Protocol_authority] = []

    /// data not used
    var data: Data = SwiftProtobuf.Internal.emptyData

    ///only support size = 1,  repeated list here for extension
    var contract: [Protocol_Transaction.Contract] = []

    /// scripts not used
    var scripts: Data = SwiftProtobuf.Internal.emptyData

    var timestamp: Int64 = 0

    var feeLimit: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Protocol_TransactionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  var fee: Int64 {
    get {return _storage._fee}
    set {_uniqueStorage()._fee = newValue}
  }

  var blockNumber: Int64 {
    get {return _storage._blockNumber}
    set {_uniqueStorage()._blockNumber = newValue}
  }

  var blockTimeStamp: Int64 {
    get {return _storage._blockTimeStamp}
    set {_uniqueStorage()._blockTimeStamp = newValue}
  }

  var contractResult: [Data] {
    get {return _storage._contractResult}
    set {_uniqueStorage()._contractResult = newValue}
  }

  var contractAddress: Data {
    get {return _storage._contractAddress}
    set {_uniqueStorage()._contractAddress = newValue}
  }

  var receipt: Protocol_ResourceReceipt {
    get {return _storage._receipt ?? Protocol_ResourceReceipt()}
    set {_uniqueStorage()._receipt = newValue}
  }
  /// Returns true if `receipt` has been explicitly set.
  var hasReceipt: Bool {return _storage._receipt != nil}
  /// Clears the value of `receipt`. Subsequent reads from it will return its default value.
  mutating func clearReceipt() {_uniqueStorage()._receipt = nil}

  var log: [Protocol_TransactionInfo.Log] {
    get {return _storage._log}
    set {_uniqueStorage()._log = newValue}
  }

  var result: Protocol_TransactionInfo.code {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  var resMessage: Data {
    get {return _storage._resMessage}
    set {_uniqueStorage()._resMessage = newValue}
  }

  var withdrawAmount: Int64 {
    get {return _storage._withdrawAmount}
    set {_uniqueStorage()._withdrawAmount = newValue}
  }

  var unfreezeAmount: Int64 {
    get {return _storage._unfreezeAmount}
    set {_uniqueStorage()._unfreezeAmount = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum code: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case sucess // = 0
    case failed // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .sucess
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sucess
      case 1: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .sucess: return 0
      case .failed: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  struct Log {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var address: Data = SwiftProtobuf.Internal.emptyData

    var topics: [Data] = []

    var data: Data = SwiftProtobuf.Internal.emptyData

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Protocol_TransactionInfo.code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Protocol_TransactionInfo.code] = [
    .sucess,
    .failed,
  ]
}

#endif  // swift(>=4.2)

struct Protocol_Transactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactions: [Protocol_Transaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_TransactionSign {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transaction: Protocol_Transaction {
    get {return _storage._transaction ?? Protocol_Transaction()}
    set {_uniqueStorage()._transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  var hasTransaction: Bool {return _storage._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  mutating func clearTransaction() {_uniqueStorage()._transaction = nil}

  var privateKey: Data {
    get {return _storage._privateKey}
    set {_uniqueStorage()._privateKey = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Protocol_BlockHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rawData: Protocol_BlockHeader.raw {
    get {return _storage._rawData ?? Protocol_BlockHeader.raw()}
    set {_uniqueStorage()._rawData = newValue}
  }
  /// Returns true if `rawData` has been explicitly set.
  var hasRawData: Bool {return _storage._rawData != nil}
  /// Clears the value of `rawData`. Subsequent reads from it will return its default value.
  mutating func clearRawData() {_uniqueStorage()._rawData = nil}

  var witnessSignature: Data {
    get {return _storage._witnessSignature}
    set {_uniqueStorage()._witnessSignature = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct raw {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var timestamp: Int64 = 0

    var txTrieRoot: Data = SwiftProtobuf.Internal.emptyData

    var parentHash: Data = SwiftProtobuf.Internal.emptyData

    ///bytes nonce = 5;
    ///bytes difficulty = 6;
    var number: Int64 = 0

    var witnessID: Int64 = 0

    var witnessAddress: Data = SwiftProtobuf.Internal.emptyData

    var version: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// block
struct Protocol_Block {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactions: [Protocol_Transaction] {
    get {return _storage._transactions}
    set {_uniqueStorage()._transactions = newValue}
  }

  var blockHeader: Protocol_BlockHeader {
    get {return _storage._blockHeader ?? Protocol_BlockHeader()}
    set {_uniqueStorage()._blockHeader = newValue}
  }
  /// Returns true if `blockHeader` has been explicitly set.
  var hasBlockHeader: Bool {return _storage._blockHeader != nil}
  /// Clears the value of `blockHeader`. Subsequent reads from it will return its default value.
  mutating func clearBlockHeader() {_uniqueStorage()._blockHeader = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Protocol_ChainInventory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ids: [Protocol_ChainInventory.BlockId] = []

  var remainNum: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct BlockId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hash: Data = SwiftProtobuf.Internal.emptyData

    var number: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Inventory
struct Protocol_BlockInventory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ids: [Protocol_BlockInventory.BlockId] = []

  var type: Protocol_BlockInventory.TypeEnum = .sync

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case sync // = 0
    case advtise // = 1
    case fetch // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .sync
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sync
      case 1: self = .advtise
      case 2: self = .fetch
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .sync: return 0
      case .advtise: return 1
      case .fetch: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  struct BlockId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hash: Data = SwiftProtobuf.Internal.emptyData

    var number: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension Protocol_BlockInventory.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Protocol_BlockInventory.TypeEnum] = [
    .sync,
    .advtise,
    .fetch,
  ]
}

#endif  // swift(>=4.2)

struct Protocol_Inventory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Protocol_Inventory.InventoryType = .trx

  var ids: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum InventoryType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case trx // = 0
    case block // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .trx
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .trx
      case 1: self = .block
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .trx: return 0
      case .block: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Protocol_Inventory.InventoryType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Protocol_Inventory.InventoryType] = [
    .trx,
    .block,
  ]
}

#endif  // swift(>=4.2)

struct Protocol_Items {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Protocol_Items.ItemType = .err

  var blocks: [Protocol_Block] = []

  var blockHeaders: [Protocol_BlockHeader] = []

  var transactions: [Protocol_Transaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ItemType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case err // = 0
    case trx // = 1
    case block // = 2
    case blockheader // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .err
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .err
      case 1: self = .trx
      case 2: self = .block
      case 3: self = .blockheader
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .err: return 0
      case .trx: return 1
      case .block: return 2
      case .blockheader: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Protocol_Items.ItemType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Protocol_Items.ItemType] = [
    .err,
    .trx,
    .block,
    .blockheader,
  ]
}

#endif  // swift(>=4.2)

/// DynamicProperties
struct Protocol_DynamicProperties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var lastSolidityBlockNum: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_DisconnectMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reason: Protocol_ReasonCode = .requested

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Protocol_HelloMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var from: Protocol_Endpoint {
    get {return _storage._from ?? Protocol_Endpoint()}
    set {_uniqueStorage()._from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  var hasFrom: Bool {return _storage._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  mutating func clearFrom() {_uniqueStorage()._from = nil}

  var version: Int32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  var timestamp: Int64 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  var genesisBlockID: Protocol_HelloMessage.BlockId {
    get {return _storage._genesisBlockID ?? Protocol_HelloMessage.BlockId()}
    set {_uniqueStorage()._genesisBlockID = newValue}
  }
  /// Returns true if `genesisBlockID` has been explicitly set.
  var hasGenesisBlockID: Bool {return _storage._genesisBlockID != nil}
  /// Clears the value of `genesisBlockID`. Subsequent reads from it will return its default value.
  mutating func clearGenesisBlockID() {_uniqueStorage()._genesisBlockID = nil}

  var solidBlockID: Protocol_HelloMessage.BlockId {
    get {return _storage._solidBlockID ?? Protocol_HelloMessage.BlockId()}
    set {_uniqueStorage()._solidBlockID = newValue}
  }
  /// Returns true if `solidBlockID` has been explicitly set.
  var hasSolidBlockID: Bool {return _storage._solidBlockID != nil}
  /// Clears the value of `solidBlockID`. Subsequent reads from it will return its default value.
  mutating func clearSolidBlockID() {_uniqueStorage()._solidBlockID = nil}

  var headBlockID: Protocol_HelloMessage.BlockId {
    get {return _storage._headBlockID ?? Protocol_HelloMessage.BlockId()}
    set {_uniqueStorage()._headBlockID = newValue}
  }
  /// Returns true if `headBlockID` has been explicitly set.
  var hasHeadBlockID: Bool {return _storage._headBlockID != nil}
  /// Clears the value of `headBlockID`. Subsequent reads from it will return its default value.
  mutating func clearHeadBlockID() {_uniqueStorage()._headBlockID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct BlockId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var hash: Data = SwiftProtobuf.Internal.emptyData

    var number: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Protocol_SmartContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var originAddress: Data {
    get {return _storage._originAddress}
    set {_uniqueStorage()._originAddress = newValue}
  }

  var contractAddress: Data {
    get {return _storage._contractAddress}
    set {_uniqueStorage()._contractAddress = newValue}
  }

  var abi: Protocol_SmartContract.ABI {
    get {return _storage._abi ?? Protocol_SmartContract.ABI()}
    set {_uniqueStorage()._abi = newValue}
  }
  /// Returns true if `abi` has been explicitly set.
  var hasAbi: Bool {return _storage._abi != nil}
  /// Clears the value of `abi`. Subsequent reads from it will return its default value.
  mutating func clearAbi() {_uniqueStorage()._abi = nil}

  var bytecode: Data {
    get {return _storage._bytecode}
    set {_uniqueStorage()._bytecode = newValue}
  }

  var callValue: Int64 {
    get {return _storage._callValue}
    set {_uniqueStorage()._callValue = newValue}
  }

  var consumeUserResourcePercent: Int64 {
    get {return _storage._consumeUserResourcePercent}
    set {_uniqueStorage()._consumeUserResourcePercent = newValue}
  }

  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ABI {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var entrys: [Protocol_SmartContract.ABI.Entry] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Entry {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var anonymous: Bool = false

      var constant: Bool = false

      var name: String = String()

      var inputs: [Protocol_SmartContract.ABI.Entry.Param] = []

      var outputs: [Protocol_SmartContract.ABI.Entry.Param] = []

      var type: Protocol_SmartContract.ABI.Entry.EntryType = .unknownEntryType

      var payable: Bool = false

      var stateMutability: Protocol_SmartContract.ABI.Entry.StateMutabilityType = .unknownMutabilityType

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum EntryType: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case unknownEntryType // = 0
        case constructor // = 1
        case function // = 2
        case event // = 3
        case fallback // = 4
        case UNRECOGNIZED(Int)

        init() {
          self = .unknownEntryType
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknownEntryType
          case 1: self = .constructor
          case 2: self = .function
          case 3: self = .event
          case 4: self = .fallback
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknownEntryType: return 0
          case .constructor: return 1
          case .function: return 2
          case .event: return 3
          case .fallback: return 4
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      enum StateMutabilityType: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case unknownMutabilityType // = 0
        case pure // = 1
        case view // = 2
        case nonpayable // = 3
        case payable // = 4
        case UNRECOGNIZED(Int)

        init() {
          self = .unknownMutabilityType
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknownMutabilityType
          case 1: self = .pure
          case 2: self = .view
          case 3: self = .nonpayable
          case 4: self = .payable
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknownMutabilityType: return 0
          case .pure: return 1
          case .view: return 2
          case .nonpayable: return 3
          case .payable: return 4
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      struct Param {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        var indexed: Bool = false

        var name: String = String()

        /// SolidityType type = 3;
        var type: String = String()

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}
      }

      init() {}
    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocol"

extension Protocol_AccountType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Normal"),
    1: .same(proto: "AssetIssue"),
    2: .same(proto: "Contract"),
  ]
}

extension Protocol_ReasonCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REQUESTED"),
    2: .same(proto: "BAD_PROTOCOL"),
    4: .same(proto: "TOO_MANY_PEERS"),
    5: .same(proto: "DUPLICATE_PEER"),
    6: .same(proto: "INCOMPATIBLE_PROTOCOL"),
    7: .same(proto: "NULL_IDENTITY"),
    8: .same(proto: "PEER_QUITING"),
    9: .same(proto: "UNEXPECTED_IDENTITY"),
    10: .same(proto: "LOCAL_IDENTITY"),
    11: .same(proto: "PING_TIMEOUT"),
    16: .same(proto: "USER_REASON"),
    17: .same(proto: "RESET"),
    18: .same(proto: "SYNC_FAIL"),
    19: .same(proto: "FETCH_FAIL"),
    20: .same(proto: "BAD_TX"),
    21: .same(proto: "BAD_BLOCK"),
    22: .same(proto: "FORKED"),
    23: .same(proto: "UNLINKABLE"),
    24: .same(proto: "INCOMPATIBLE_VERSION"),
    25: .same(proto: "INCOMPATIBLE_CHAIN"),
    32: .same(proto: "TIME_OUT"),
    33: .same(proto: "CONNECT_FAIL"),
    34: .same(proto: "TOO_MANY_PEERS_WITH_SAME_IP"),
    255: .same(proto: "UNKNOWN"),
  ]
}

extension Protocol_AccountId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.name)
      case 2: try decoder.decodeSingularBytesField(value: &self.address)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularBytesField(value: self.name, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_AccountId, rhs: Protocol_AccountId) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Vote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Vote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vote_address"),
    2: .standard(proto: "vote_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.voteAddress)
      case 2: try decoder.decodeSingularInt64Field(value: &self.voteCount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.voteAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.voteAddress, fieldNumber: 1)
    }
    if self.voteCount != 0 {
      try visitor.visitSingularInt64Field(value: self.voteCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Vote, rhs: Protocol_Vote) -> Bool {
    if lhs.voteAddress != rhs.voteAddress {return false}
    if lhs.voteCount != rhs.voteCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Proposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Proposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "proposal_id"),
    2: .standard(proto: "proposer_address"),
    3: .same(proto: "parameters"),
    4: .standard(proto: "expiration_time"),
    5: .standard(proto: "create_time"),
    6: .same(proto: "approvals"),
    7: .same(proto: "state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.proposalID)
      case 2: try decoder.decodeSingularBytesField(value: &self.proposerAddress)
      case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt64>.self, value: &self.parameters)
      case 4: try decoder.decodeSingularInt64Field(value: &self.expirationTime)
      case 5: try decoder.decodeSingularInt64Field(value: &self.createTime)
      case 6: try decoder.decodeRepeatedBytesField(value: &self.approvals)
      case 7: try decoder.decodeSingularEnumField(value: &self.state)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.proposalID != 0 {
      try visitor.visitSingularInt64Field(value: self.proposalID, fieldNumber: 1)
    }
    if !self.proposerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.proposerAddress, fieldNumber: 2)
    }
    if !self.parameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt64>.self, value: self.parameters, fieldNumber: 3)
    }
    if self.expirationTime != 0 {
      try visitor.visitSingularInt64Field(value: self.expirationTime, fieldNumber: 4)
    }
    if self.createTime != 0 {
      try visitor.visitSingularInt64Field(value: self.createTime, fieldNumber: 5)
    }
    if !self.approvals.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.approvals, fieldNumber: 6)
    }
    if self.state != .pending {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Proposal, rhs: Protocol_Proposal) -> Bool {
    if lhs.proposalID != rhs.proposalID {return false}
    if lhs.proposerAddress != rhs.proposerAddress {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.expirationTime != rhs.expirationTime {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.approvals != rhs.approvals {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Proposal.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "DISAPPROVED"),
    2: .same(proto: "APPROVED"),
    3: .same(proto: "CANCELED"),
  ]
}

extension Protocol_Exchange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Exchange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exchange_id"),
    2: .standard(proto: "creator_address"),
    3: .standard(proto: "create_time"),
    6: .standard(proto: "first_token_id"),
    7: .standard(proto: "first_token_balance"),
    8: .standard(proto: "second_token_id"),
    9: .standard(proto: "second_token_balance"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.exchangeID)
      case 2: try decoder.decodeSingularBytesField(value: &self.creatorAddress)
      case 3: try decoder.decodeSingularInt64Field(value: &self.createTime)
      case 6: try decoder.decodeSingularBytesField(value: &self.firstTokenID)
      case 7: try decoder.decodeSingularInt64Field(value: &self.firstTokenBalance)
      case 8: try decoder.decodeSingularBytesField(value: &self.secondTokenID)
      case 9: try decoder.decodeSingularInt64Field(value: &self.secondTokenBalance)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.exchangeID != 0 {
      try visitor.visitSingularInt64Field(value: self.exchangeID, fieldNumber: 1)
    }
    if !self.creatorAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.creatorAddress, fieldNumber: 2)
    }
    if self.createTime != 0 {
      try visitor.visitSingularInt64Field(value: self.createTime, fieldNumber: 3)
    }
    if !self.firstTokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.firstTokenID, fieldNumber: 6)
    }
    if self.firstTokenBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.firstTokenBalance, fieldNumber: 7)
    }
    if !self.secondTokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.secondTokenID, fieldNumber: 8)
    }
    if self.secondTokenBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.secondTokenBalance, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Exchange, rhs: Protocol_Exchange) -> Bool {
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.creatorAddress != rhs.creatorAddress {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.firstTokenID != rhs.firstTokenID {return false}
    if lhs.firstTokenBalance != rhs.firstTokenBalance {return false}
    if lhs.secondTokenID != rhs.secondTokenID {return false}
    if lhs.secondTokenBalance != rhs.secondTokenBalance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ChainParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChainParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chainParameter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.chainParameter)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chainParameter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chainParameter, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_ChainParameters, rhs: Protocol_ChainParameters) -> Bool {
    if lhs.chainParameter != rhs.chainParameter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ChainParameters.ChainParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_ChainParameters.protoMessageName + ".ChainParameter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.key)
      case 2: try decoder.decodeSingularInt64Field(value: &self.value)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_ChainParameters.ChainParameter, rhs: Protocol_ChainParameters.ChainParameter) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Account: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Account"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_name"),
    2: .same(proto: "type"),
    3: .same(proto: "address"),
    4: .same(proto: "balance"),
    5: .same(proto: "votes"),
    6: .same(proto: "asset"),
    7: .same(proto: "frozen"),
    8: .standard(proto: "net_usage"),
    9: .standard(proto: "create_time"),
    10: .standard(proto: "latest_opration_time"),
    11: .same(proto: "allowance"),
    12: .standard(proto: "latest_withdraw_time"),
    13: .same(proto: "code"),
    14: .standard(proto: "is_witness"),
    15: .standard(proto: "is_committee"),
    16: .standard(proto: "frozen_supply"),
    17: .standard(proto: "asset_issued_name"),
    18: .standard(proto: "latest_asset_operation_time"),
    19: .standard(proto: "free_net_usage"),
    20: .standard(proto: "free_asset_net_usage"),
    21: .standard(proto: "latest_consume_time"),
    22: .standard(proto: "latest_consume_free_time"),
    23: .standard(proto: "account_id"),
    26: .standard(proto: "account_resource"),
    30: .same(proto: "codeHash"),
  ]

  fileprivate class _StorageClass {
    var _accountName: Data = SwiftProtobuf.Internal.emptyData
    var _type: Protocol_AccountType = .normal
    var _address: Data = SwiftProtobuf.Internal.emptyData
    var _balance: Int64 = 0
    var _votes: [Protocol_Vote] = []
    var _asset: Dictionary<String,Int64> = [:]
    var _frozen: [Protocol_Account.Frozen] = []
    var _netUsage: Int64 = 0
    var _createTime: Int64 = 0
    var _latestOprationTime: Int64 = 0
    var _allowance: Int64 = 0
    var _latestWithdrawTime: Int64 = 0
    var _code: Data = SwiftProtobuf.Internal.emptyData
    var _isWitness: Bool = false
    var _isCommittee: Bool = false
    var _frozenSupply: [Protocol_Account.Frozen] = []
    var _assetIssuedName: Data = SwiftProtobuf.Internal.emptyData
    var _latestAssetOperationTime: Dictionary<String,Int64> = [:]
    var _freeNetUsage: Int64 = 0
    var _freeAssetNetUsage: Dictionary<String,Int64> = [:]
    var _latestConsumeTime: Int64 = 0
    var _latestConsumeFreeTime: Int64 = 0
    var _accountID: Data = SwiftProtobuf.Internal.emptyData
    var _accountResource: Protocol_Account.AccountResource? = nil
    var _codeHash: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accountName = source._accountName
      _type = source._type
      _address = source._address
      _balance = source._balance
      _votes = source._votes
      _asset = source._asset
      _frozen = source._frozen
      _netUsage = source._netUsage
      _createTime = source._createTime
      _latestOprationTime = source._latestOprationTime
      _allowance = source._allowance
      _latestWithdrawTime = source._latestWithdrawTime
      _code = source._code
      _isWitness = source._isWitness
      _isCommittee = source._isCommittee
      _frozenSupply = source._frozenSupply
      _assetIssuedName = source._assetIssuedName
      _latestAssetOperationTime = source._latestAssetOperationTime
      _freeNetUsage = source._freeNetUsage
      _freeAssetNetUsage = source._freeAssetNetUsage
      _latestConsumeTime = source._latestConsumeTime
      _latestConsumeFreeTime = source._latestConsumeFreeTime
      _accountID = source._accountID
      _accountResource = source._accountResource
      _codeHash = source._codeHash
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._accountName)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._address)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._balance)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._votes)
        case 6: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._asset)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._frozen)
        case 8: try decoder.decodeSingularInt64Field(value: &_storage._netUsage)
        case 9: try decoder.decodeSingularInt64Field(value: &_storage._createTime)
        case 10: try decoder.decodeSingularInt64Field(value: &_storage._latestOprationTime)
        case 11: try decoder.decodeSingularInt64Field(value: &_storage._allowance)
        case 12: try decoder.decodeSingularInt64Field(value: &_storage._latestWithdrawTime)
        case 13: try decoder.decodeSingularBytesField(value: &_storage._code)
        case 14: try decoder.decodeSingularBoolField(value: &_storage._isWitness)
        case 15: try decoder.decodeSingularBoolField(value: &_storage._isCommittee)
        case 16: try decoder.decodeRepeatedMessageField(value: &_storage._frozenSupply)
        case 17: try decoder.decodeSingularBytesField(value: &_storage._assetIssuedName)
        case 18: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._latestAssetOperationTime)
        case 19: try decoder.decodeSingularInt64Field(value: &_storage._freeNetUsage)
        case 20: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._freeAssetNetUsage)
        case 21: try decoder.decodeSingularInt64Field(value: &_storage._latestConsumeTime)
        case 22: try decoder.decodeSingularInt64Field(value: &_storage._latestConsumeFreeTime)
        case 23: try decoder.decodeSingularBytesField(value: &_storage._accountID)
        case 26: try decoder.decodeSingularMessageField(value: &_storage._accountResource)
        case 30: try decoder.decodeSingularBytesField(value: &_storage._codeHash)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._accountName.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._accountName, fieldNumber: 1)
      }
      if _storage._type != .normal {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._address, fieldNumber: 3)
      }
      if _storage._balance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._balance, fieldNumber: 4)
      }
      if !_storage._votes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._votes, fieldNumber: 5)
      }
      if !_storage._asset.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: _storage._asset, fieldNumber: 6)
      }
      if !_storage._frozen.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._frozen, fieldNumber: 7)
      }
      if _storage._netUsage != 0 {
        try visitor.visitSingularInt64Field(value: _storage._netUsage, fieldNumber: 8)
      }
      if _storage._createTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createTime, fieldNumber: 9)
      }
      if _storage._latestOprationTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._latestOprationTime, fieldNumber: 10)
      }
      if _storage._allowance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._allowance, fieldNumber: 11)
      }
      if _storage._latestWithdrawTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._latestWithdrawTime, fieldNumber: 12)
      }
      if !_storage._code.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._code, fieldNumber: 13)
      }
      if _storage._isWitness != false {
        try visitor.visitSingularBoolField(value: _storage._isWitness, fieldNumber: 14)
      }
      if _storage._isCommittee != false {
        try visitor.visitSingularBoolField(value: _storage._isCommittee, fieldNumber: 15)
      }
      if !_storage._frozenSupply.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._frozenSupply, fieldNumber: 16)
      }
      if !_storage._assetIssuedName.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._assetIssuedName, fieldNumber: 17)
      }
      if !_storage._latestAssetOperationTime.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: _storage._latestAssetOperationTime, fieldNumber: 18)
      }
      if _storage._freeNetUsage != 0 {
        try visitor.visitSingularInt64Field(value: _storage._freeNetUsage, fieldNumber: 19)
      }
      if !_storage._freeAssetNetUsage.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: _storage._freeAssetNetUsage, fieldNumber: 20)
      }
      if _storage._latestConsumeTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._latestConsumeTime, fieldNumber: 21)
      }
      if _storage._latestConsumeFreeTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._latestConsumeFreeTime, fieldNumber: 22)
      }
      if !_storage._accountID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._accountID, fieldNumber: 23)
      }
      if let v = _storage._accountResource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }
      if !_storage._codeHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._codeHash, fieldNumber: 30)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Account, rhs: Protocol_Account) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accountName != rhs_storage._accountName {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._votes != rhs_storage._votes {return false}
        if _storage._asset != rhs_storage._asset {return false}
        if _storage._frozen != rhs_storage._frozen {return false}
        if _storage._netUsage != rhs_storage._netUsage {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._latestOprationTime != rhs_storage._latestOprationTime {return false}
        if _storage._allowance != rhs_storage._allowance {return false}
        if _storage._latestWithdrawTime != rhs_storage._latestWithdrawTime {return false}
        if _storage._code != rhs_storage._code {return false}
        if _storage._isWitness != rhs_storage._isWitness {return false}
        if _storage._isCommittee != rhs_storage._isCommittee {return false}
        if _storage._frozenSupply != rhs_storage._frozenSupply {return false}
        if _storage._assetIssuedName != rhs_storage._assetIssuedName {return false}
        if _storage._latestAssetOperationTime != rhs_storage._latestAssetOperationTime {return false}
        if _storage._freeNetUsage != rhs_storage._freeNetUsage {return false}
        if _storage._freeAssetNetUsage != rhs_storage._freeAssetNetUsage {return false}
        if _storage._latestConsumeTime != rhs_storage._latestConsumeTime {return false}
        if _storage._latestConsumeFreeTime != rhs_storage._latestConsumeFreeTime {return false}
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._accountResource != rhs_storage._accountResource {return false}
        if _storage._codeHash != rhs_storage._codeHash {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Account.Frozen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Account.protoMessageName + ".Frozen"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "frozen_balance"),
    2: .standard(proto: "expire_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.frozenBalance)
      case 2: try decoder.decodeSingularInt64Field(value: &self.expireTime)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frozenBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.frozenBalance, fieldNumber: 1)
    }
    if self.expireTime != 0 {
      try visitor.visitSingularInt64Field(value: self.expireTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Account.Frozen, rhs: Protocol_Account.Frozen) -> Bool {
    if lhs.frozenBalance != rhs.frozenBalance {return false}
    if lhs.expireTime != rhs.expireTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Account.AccountResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Account.protoMessageName + ".AccountResource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "energy_usage"),
    2: .standard(proto: "frozen_balance_for_energy"),
    3: .standard(proto: "latest_consume_time_for_energy"),
    6: .standard(proto: "storage_limit"),
    7: .standard(proto: "storage_usage"),
    8: .standard(proto: "latest_exchange_storage_time"),
  ]

  fileprivate class _StorageClass {
    var _energyUsage: Int64 = 0
    var _frozenBalanceForEnergy: Protocol_Account.Frozen? = nil
    var _latestConsumeTimeForEnergy: Int64 = 0
    var _storageLimit: Int64 = 0
    var _storageUsage: Int64 = 0
    var _latestExchangeStorageTime: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _energyUsage = source._energyUsage
      _frozenBalanceForEnergy = source._frozenBalanceForEnergy
      _latestConsumeTimeForEnergy = source._latestConsumeTimeForEnergy
      _storageLimit = source._storageLimit
      _storageUsage = source._storageUsage
      _latestExchangeStorageTime = source._latestExchangeStorageTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt64Field(value: &_storage._energyUsage)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._frozenBalanceForEnergy)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._latestConsumeTimeForEnergy)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._storageLimit)
        case 7: try decoder.decodeSingularInt64Field(value: &_storage._storageUsage)
        case 8: try decoder.decodeSingularInt64Field(value: &_storage._latestExchangeStorageTime)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._energyUsage != 0 {
        try visitor.visitSingularInt64Field(value: _storage._energyUsage, fieldNumber: 1)
      }
      if let v = _storage._frozenBalanceForEnergy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._latestConsumeTimeForEnergy != 0 {
        try visitor.visitSingularInt64Field(value: _storage._latestConsumeTimeForEnergy, fieldNumber: 3)
      }
      if _storage._storageLimit != 0 {
        try visitor.visitSingularInt64Field(value: _storage._storageLimit, fieldNumber: 6)
      }
      if _storage._storageUsage != 0 {
        try visitor.visitSingularInt64Field(value: _storage._storageUsage, fieldNumber: 7)
      }
      if _storage._latestExchangeStorageTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._latestExchangeStorageTime, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Account.AccountResource, rhs: Protocol_Account.AccountResource) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._energyUsage != rhs_storage._energyUsage {return false}
        if _storage._frozenBalanceForEnergy != rhs_storage._frozenBalanceForEnergy {return false}
        if _storage._latestConsumeTimeForEnergy != rhs_storage._latestConsumeTimeForEnergy {return false}
        if _storage._storageLimit != rhs_storage._storageLimit {return false}
        if _storage._storageUsage != rhs_storage._storageUsage {return false}
        if _storage._latestExchangeStorageTime != rhs_storage._latestExchangeStorageTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_authority: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".authority"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "permission_name"),
  ]

  fileprivate class _StorageClass {
    var _account: Protocol_AccountId? = nil
    var _permissionName: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _permissionName = source._permissionName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._permissionName)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._permissionName.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._permissionName, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_authority, rhs: Protocol_authority) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._permissionName != rhs_storage._permissionName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_permission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".permission"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
  ]

  fileprivate class _StorageClass {
    var _account: Protocol_AccountId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_permission, rhs: Protocol_permission) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Witness: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Witness"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "voteCount"),
    3: .same(proto: "pubKey"),
    4: .same(proto: "url"),
    5: .same(proto: "totalProduced"),
    6: .same(proto: "totalMissed"),
    7: .same(proto: "latestBlockNum"),
    8: .same(proto: "latestSlotNum"),
    9: .same(proto: "isJobs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.address)
      case 2: try decoder.decodeSingularInt64Field(value: &self.voteCount)
      case 3: try decoder.decodeSingularBytesField(value: &self.pubKey)
      case 4: try decoder.decodeSingularStringField(value: &self.url)
      case 5: try decoder.decodeSingularInt64Field(value: &self.totalProduced)
      case 6: try decoder.decodeSingularInt64Field(value: &self.totalMissed)
      case 7: try decoder.decodeSingularInt64Field(value: &self.latestBlockNum)
      case 8: try decoder.decodeSingularInt64Field(value: &self.latestSlotNum)
      case 9: try decoder.decodeSingularBoolField(value: &self.isJobs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if self.voteCount != 0 {
      try visitor.visitSingularInt64Field(value: self.voteCount, fieldNumber: 2)
    }
    if !self.pubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubKey, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    if self.totalProduced != 0 {
      try visitor.visitSingularInt64Field(value: self.totalProduced, fieldNumber: 5)
    }
    if self.totalMissed != 0 {
      try visitor.visitSingularInt64Field(value: self.totalMissed, fieldNumber: 6)
    }
    if self.latestBlockNum != 0 {
      try visitor.visitSingularInt64Field(value: self.latestBlockNum, fieldNumber: 7)
    }
    if self.latestSlotNum != 0 {
      try visitor.visitSingularInt64Field(value: self.latestSlotNum, fieldNumber: 8)
    }
    if self.isJobs != false {
      try visitor.visitSingularBoolField(value: self.isJobs, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Witness, rhs: Protocol_Witness) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.voteCount != rhs.voteCount {return false}
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.url != rhs.url {return false}
    if lhs.totalProduced != rhs.totalProduced {return false}
    if lhs.totalMissed != rhs.totalMissed {return false}
    if lhs.latestBlockNum != rhs.latestBlockNum {return false}
    if lhs.latestSlotNum != rhs.latestSlotNum {return false}
    if lhs.isJobs != rhs.isJobs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Votes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Votes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "old_votes"),
    3: .standard(proto: "new_votes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.address)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.oldVotes)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.newVotes)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if !self.oldVotes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldVotes, fieldNumber: 2)
    }
    if !self.newVotes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.newVotes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Votes, rhs: Protocol_Votes) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.oldVotes != rhs.oldVotes {return false}
    if lhs.newVotes != rhs.newVotes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TXOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TXOutput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "pubKeyHash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.value)
      case 2: try decoder.decodeSingularBytesField(value: &self.pubKeyHash)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 1)
    }
    if !self.pubKeyHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubKeyHash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_TXOutput, rhs: Protocol_TXOutput) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.pubKeyHash != rhs.pubKeyHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TXInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TXInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_data"),
    4: .same(proto: "signature"),
  ]

  fileprivate class _StorageClass {
    var _rawData: Protocol_TXInput.raw? = nil
    var _signature: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rawData = source._rawData
      _signature = source._signature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._rawData)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._signature)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._rawData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_TXInput, rhs: Protocol_TXInput) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rawData != rhs_storage._rawData {return false}
        if _storage._signature != rhs_storage._signature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TXInput.raw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_TXInput.protoMessageName + ".raw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txID"),
    2: .same(proto: "vout"),
    3: .same(proto: "pubKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.txID)
      case 2: try decoder.decodeSingularInt64Field(value: &self.vout)
      case 3: try decoder.decodeSingularBytesField(value: &self.pubKey)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txID.isEmpty {
      try visitor.visitSingularBytesField(value: self.txID, fieldNumber: 1)
    }
    if self.vout != 0 {
      try visitor.visitSingularInt64Field(value: self.vout, fieldNumber: 2)
    }
    if !self.pubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_TXInput.raw, rhs: Protocol_TXInput.raw) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs.vout != rhs.vout {return false}
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TXOutputs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TXOutputs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.outputs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_TXOutputs, rhs: Protocol_TXOutputs) -> Bool {
    if lhs.outputs != rhs.outputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ResourceReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResourceReceipt"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "energy_usage"),
    2: .standard(proto: "energy_fee"),
    3: .standard(proto: "origin_energy_usage"),
    4: .standard(proto: "energy_usage_total"),
    5: .standard(proto: "net_usage"),
    6: .standard(proto: "net_fee"),
    7: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.energyUsage)
      case 2: try decoder.decodeSingularInt64Field(value: &self.energyFee)
      case 3: try decoder.decodeSingularInt64Field(value: &self.originEnergyUsage)
      case 4: try decoder.decodeSingularInt64Field(value: &self.energyUsageTotal)
      case 5: try decoder.decodeSingularInt64Field(value: &self.netUsage)
      case 6: try decoder.decodeSingularInt64Field(value: &self.netFee)
      case 7: try decoder.decodeSingularEnumField(value: &self.result)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.energyUsage != 0 {
      try visitor.visitSingularInt64Field(value: self.energyUsage, fieldNumber: 1)
    }
    if self.energyFee != 0 {
      try visitor.visitSingularInt64Field(value: self.energyFee, fieldNumber: 2)
    }
    if self.originEnergyUsage != 0 {
      try visitor.visitSingularInt64Field(value: self.originEnergyUsage, fieldNumber: 3)
    }
    if self.energyUsageTotal != 0 {
      try visitor.visitSingularInt64Field(value: self.energyUsageTotal, fieldNumber: 4)
    }
    if self.netUsage != 0 {
      try visitor.visitSingularInt64Field(value: self.netUsage, fieldNumber: 5)
    }
    if self.netFee != 0 {
      try visitor.visitSingularInt64Field(value: self.netFee, fieldNumber: 6)
    }
    if self.result != .default {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_ResourceReceipt, rhs: Protocol_ResourceReceipt) -> Bool {
    if lhs.energyUsage != rhs.energyUsage {return false}
    if lhs.energyFee != rhs.energyFee {return false}
    if lhs.originEnergyUsage != rhs.originEnergyUsage {return false}
    if lhs.energyUsageTotal != rhs.energyUsageTotal {return false}
    if lhs.netUsage != rhs.netUsage {return false}
    if lhs.netFee != rhs.netFee {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_data"),
    2: .same(proto: "signature"),
    5: .same(proto: "ret"),
  ]

  fileprivate class _StorageClass {
    var _rawData: Protocol_Transaction.raw? = nil
    var _signature: [Data] = []
    var _ret: [Protocol_Transaction.Result] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rawData = source._rawData
      _signature = source._signature
      _ret = source._ret
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._rawData)
        case 2: try decoder.decodeRepeatedBytesField(value: &_storage._signature)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._ret)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._rawData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._signature, fieldNumber: 2)
      }
      if !_storage._ret.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ret, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Transaction, rhs: Protocol_Transaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rawData != rhs_storage._rawData {return false}
        if _storage._signature != rhs_storage._signature {return false}
        if _storage._ret != rhs_storage._ret {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Transaction.Contract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Transaction.protoMessageName + ".Contract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "parameter"),
    3: .same(proto: "provider"),
    4: .same(proto: "ContractName"),
  ]

  fileprivate class _StorageClass {
    var _type: Protocol_Transaction.Contract.ContractType = .accountCreateContract
    var _parameter: SwiftProtobuf.Google_Protobuf_Any? = nil
    var _provider: Data = SwiftProtobuf.Internal.emptyData
    var _contractName: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _parameter = source._parameter
      _provider = source._provider
      _contractName = source._contractName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._parameter)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._provider)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._contractName)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .accountCreateContract {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if let v = _storage._parameter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._provider.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._provider, fieldNumber: 3)
      }
      if !_storage._contractName.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._contractName, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Transaction.Contract, rhs: Protocol_Transaction.Contract) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._parameter != rhs_storage._parameter {return false}
        if _storage._provider != rhs_storage._provider {return false}
        if _storage._contractName != rhs_storage._contractName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Transaction.Contract.ContractType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AccountCreateContract"),
    1: .same(proto: "TransferContract"),
    2: .same(proto: "TransferAssetContract"),
    3: .same(proto: "VoteAssetContract"),
    4: .same(proto: "VoteWitnessContract"),
    5: .same(proto: "WitnessCreateContract"),
    6: .same(proto: "AssetIssueContract"),
    8: .same(proto: "WitnessUpdateContract"),
    9: .same(proto: "ParticipateAssetIssueContract"),
    10: .same(proto: "AccountUpdateContract"),
    11: .same(proto: "FreezeBalanceContract"),
    12: .same(proto: "UnfreezeBalanceContract"),
    13: .same(proto: "WithdrawBalanceContract"),
    14: .same(proto: "UnfreezeAssetContract"),
    15: .same(proto: "UpdateAssetContract"),
    16: .same(proto: "ProposalCreateContract"),
    17: .same(proto: "ProposalApproveContract"),
    18: .same(proto: "ProposalDeleteContract"),
    19: .same(proto: "SetAccountIdContract"),
    20: .same(proto: "CustomContract"),
    30: .same(proto: "CreateSmartContract"),
    31: .same(proto: "TriggerSmartContract"),
    32: .same(proto: "GetContract"),
    33: .same(proto: "UpdateSettingContract"),
    41: .same(proto: "ExchangeCreateContract"),
    42: .same(proto: "ExchangeInjectContract"),
    43: .same(proto: "ExchangeWithdrawContract"),
    44: .same(proto: "ExchangeTransactionContract"),
  ]
}

extension Protocol_Transaction.Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Transaction.protoMessageName + ".Result"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fee"),
    2: .same(proto: "ret"),
    3: .same(proto: "contractRet"),
    15: .standard(proto: "withdraw_amount"),
    16: .standard(proto: "unfreeze_amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.fee)
      case 2: try decoder.decodeSingularEnumField(value: &self.ret)
      case 3: try decoder.decodeSingularEnumField(value: &self.contractRet)
      case 15: try decoder.decodeSingularInt64Field(value: &self.withdrawAmount)
      case 16: try decoder.decodeSingularInt64Field(value: &self.unfreezeAmount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fee != 0 {
      try visitor.visitSingularInt64Field(value: self.fee, fieldNumber: 1)
    }
    if self.ret != .sucess {
      try visitor.visitSingularEnumField(value: self.ret, fieldNumber: 2)
    }
    if self.contractRet != .default {
      try visitor.visitSingularEnumField(value: self.contractRet, fieldNumber: 3)
    }
    if self.withdrawAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.withdrawAmount, fieldNumber: 15)
    }
    if self.unfreezeAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.unfreezeAmount, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Transaction.Result, rhs: Protocol_Transaction.Result) -> Bool {
    if lhs.fee != rhs.fee {return false}
    if lhs.ret != rhs.ret {return false}
    if lhs.contractRet != rhs.contractRet {return false}
    if lhs.withdrawAmount != rhs.withdrawAmount {return false}
    if lhs.unfreezeAmount != rhs.unfreezeAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Transaction.Result.code: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUCESS"),
    1: .same(proto: "FAILED"),
  ]
}

extension Protocol_Transaction.Result.contractResult: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "REVERT"),
    3: .same(proto: "BAD_JUMP_DESTINATION"),
    4: .same(proto: "OUT_OF_MEMORY"),
    5: .same(proto: "PRECOMPILED_CONTRACT"),
    6: .same(proto: "STACK_TOO_SMALL"),
    7: .same(proto: "STACK_TOO_LARGE"),
    8: .same(proto: "ILLEGAL_OPERATION"),
    9: .same(proto: "STACK_OVERFLOW"),
    10: .same(proto: "OUT_OF_ENERGY"),
    11: .same(proto: "OUT_OF_TIME"),
    12: .same(proto: "JVM_STACK_OVER_FLOW"),
    13: .same(proto: "UNKNOWN"),
  ]
}

extension Protocol_Transaction.raw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Transaction.protoMessageName + ".raw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ref_block_bytes"),
    3: .standard(proto: "ref_block_num"),
    4: .standard(proto: "ref_block_hash"),
    8: .same(proto: "expiration"),
    9: .same(proto: "auths"),
    10: .same(proto: "data"),
    11: .same(proto: "contract"),
    12: .same(proto: "scripts"),
    14: .same(proto: "timestamp"),
    18: .standard(proto: "fee_limit"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.refBlockBytes)
      case 3: try decoder.decodeSingularInt64Field(value: &self.refBlockNum)
      case 4: try decoder.decodeSingularBytesField(value: &self.refBlockHash)
      case 8: try decoder.decodeSingularInt64Field(value: &self.expiration)
      case 9: try decoder.decodeRepeatedMessageField(value: &self.auths)
      case 10: try decoder.decodeSingularBytesField(value: &self.data)
      case 11: try decoder.decodeRepeatedMessageField(value: &self.contract)
      case 12: try decoder.decodeSingularBytesField(value: &self.scripts)
      case 14: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 18: try decoder.decodeSingularInt64Field(value: &self.feeLimit)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.refBlockBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.refBlockBytes, fieldNumber: 1)
    }
    if self.refBlockNum != 0 {
      try visitor.visitSingularInt64Field(value: self.refBlockNum, fieldNumber: 3)
    }
    if !self.refBlockHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.refBlockHash, fieldNumber: 4)
    }
    if self.expiration != 0 {
      try visitor.visitSingularInt64Field(value: self.expiration, fieldNumber: 8)
    }
    if !self.auths.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.auths, fieldNumber: 9)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 10)
    }
    if !self.contract.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contract, fieldNumber: 11)
    }
    if !self.scripts.isEmpty {
      try visitor.visitSingularBytesField(value: self.scripts, fieldNumber: 12)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 14)
    }
    if self.feeLimit != 0 {
      try visitor.visitSingularInt64Field(value: self.feeLimit, fieldNumber: 18)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Transaction.raw, rhs: Protocol_Transaction.raw) -> Bool {
    if lhs.refBlockBytes != rhs.refBlockBytes {return false}
    if lhs.refBlockNum != rhs.refBlockNum {return false}
    if lhs.refBlockHash != rhs.refBlockHash {return false}
    if lhs.expiration != rhs.expiration {return false}
    if lhs.auths != rhs.auths {return false}
    if lhs.data != rhs.data {return false}
    if lhs.contract != rhs.contract {return false}
    if lhs.scripts != rhs.scripts {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.feeLimit != rhs.feeLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "fee"),
    3: .same(proto: "blockNumber"),
    4: .same(proto: "blockTimeStamp"),
    5: .same(proto: "contractResult"),
    6: .standard(proto: "contract_address"),
    7: .same(proto: "receipt"),
    8: .same(proto: "log"),
    9: .same(proto: "result"),
    10: .same(proto: "resMessage"),
    15: .standard(proto: "withdraw_amount"),
    16: .standard(proto: "unfreeze_amount"),
  ]

  fileprivate class _StorageClass {
    var _id: Data = SwiftProtobuf.Internal.emptyData
    var _fee: Int64 = 0
    var _blockNumber: Int64 = 0
    var _blockTimeStamp: Int64 = 0
    var _contractResult: [Data] = []
    var _contractAddress: Data = SwiftProtobuf.Internal.emptyData
    var _receipt: Protocol_ResourceReceipt? = nil
    var _log: [Protocol_TransactionInfo.Log] = []
    var _result: Protocol_TransactionInfo.code = .sucess
    var _resMessage: Data = SwiftProtobuf.Internal.emptyData
    var _withdrawAmount: Int64 = 0
    var _unfreezeAmount: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _fee = source._fee
      _blockNumber = source._blockNumber
      _blockTimeStamp = source._blockTimeStamp
      _contractResult = source._contractResult
      _contractAddress = source._contractAddress
      _receipt = source._receipt
      _log = source._log
      _result = source._result
      _resMessage = source._resMessage
      _withdrawAmount = source._withdrawAmount
      _unfreezeAmount = source._unfreezeAmount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._id)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._fee)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._blockNumber)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._blockTimeStamp)
        case 5: try decoder.decodeRepeatedBytesField(value: &_storage._contractResult)
        case 6: try decoder.decodeSingularBytesField(value: &_storage._contractAddress)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._receipt)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._log)
        case 9: try decoder.decodeSingularEnumField(value: &_storage._result)
        case 10: try decoder.decodeSingularBytesField(value: &_storage._resMessage)
        case 15: try decoder.decodeSingularInt64Field(value: &_storage._withdrawAmount)
        case 16: try decoder.decodeSingularInt64Field(value: &_storage._unfreezeAmount)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._id, fieldNumber: 1)
      }
      if _storage._fee != 0 {
        try visitor.visitSingularInt64Field(value: _storage._fee, fieldNumber: 2)
      }
      if _storage._blockNumber != 0 {
        try visitor.visitSingularInt64Field(value: _storage._blockNumber, fieldNumber: 3)
      }
      if _storage._blockTimeStamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._blockTimeStamp, fieldNumber: 4)
      }
      if !_storage._contractResult.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._contractResult, fieldNumber: 5)
      }
      if !_storage._contractAddress.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._contractAddress, fieldNumber: 6)
      }
      if let v = _storage._receipt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._log.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._log, fieldNumber: 8)
      }
      if _storage._result != .sucess {
        try visitor.visitSingularEnumField(value: _storage._result, fieldNumber: 9)
      }
      if !_storage._resMessage.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._resMessage, fieldNumber: 10)
      }
      if _storage._withdrawAmount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._withdrawAmount, fieldNumber: 15)
      }
      if _storage._unfreezeAmount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._unfreezeAmount, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_TransactionInfo, rhs: Protocol_TransactionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._fee != rhs_storage._fee {return false}
        if _storage._blockNumber != rhs_storage._blockNumber {return false}
        if _storage._blockTimeStamp != rhs_storage._blockTimeStamp {return false}
        if _storage._contractResult != rhs_storage._contractResult {return false}
        if _storage._contractAddress != rhs_storage._contractAddress {return false}
        if _storage._receipt != rhs_storage._receipt {return false}
        if _storage._log != rhs_storage._log {return false}
        if _storage._result != rhs_storage._result {return false}
        if _storage._resMessage != rhs_storage._resMessage {return false}
        if _storage._withdrawAmount != rhs_storage._withdrawAmount {return false}
        if _storage._unfreezeAmount != rhs_storage._unfreezeAmount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionInfo.code: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUCESS"),
    1: .same(proto: "FAILED"),
  ]
}

extension Protocol_TransactionInfo.Log: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_TransactionInfo.protoMessageName + ".Log"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "topics"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.address)
      case 2: try decoder.decodeRepeatedBytesField(value: &self.topics)
      case 3: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if !self.topics.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.topics, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_TransactionInfo.Log, rhs: Protocol_TransactionInfo.Log) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.topics != rhs.topics {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Transactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transactions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.transactions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Transactions, rhs: Protocol_Transactions) -> Bool {
    if lhs.transactions != rhs.transactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionSign: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionSign"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
    2: .same(proto: "privateKey"),
  ]

  fileprivate class _StorageClass {
    var _transaction: Protocol_Transaction? = nil
    var _privateKey: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transaction = source._transaction
      _privateKey = source._privateKey
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._transaction)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._privateKey)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._transaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._privateKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._privateKey, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_TransactionSign, rhs: Protocol_TransactionSign) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transaction != rhs_storage._transaction {return false}
        if _storage._privateKey != rhs_storage._privateKey {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockHeader"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_data"),
    2: .standard(proto: "witness_signature"),
  ]

  fileprivate class _StorageClass {
    var _rawData: Protocol_BlockHeader.raw? = nil
    var _witnessSignature: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rawData = source._rawData
      _witnessSignature = source._witnessSignature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._rawData)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._witnessSignature)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._rawData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._witnessSignature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._witnessSignature, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_BlockHeader, rhs: Protocol_BlockHeader) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rawData != rhs_storage._rawData {return false}
        if _storage._witnessSignature != rhs_storage._witnessSignature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockHeader.raw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_BlockHeader.protoMessageName + ".raw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "txTrieRoot"),
    3: .same(proto: "parentHash"),
    7: .same(proto: "number"),
    8: .standard(proto: "witness_id"),
    9: .standard(proto: "witness_address"),
    10: .same(proto: "version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 2: try decoder.decodeSingularBytesField(value: &self.txTrieRoot)
      case 3: try decoder.decodeSingularBytesField(value: &self.parentHash)
      case 7: try decoder.decodeSingularInt64Field(value: &self.number)
      case 8: try decoder.decodeSingularInt64Field(value: &self.witnessID)
      case 9: try decoder.decodeSingularBytesField(value: &self.witnessAddress)
      case 10: try decoder.decodeSingularInt32Field(value: &self.version)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.txTrieRoot.isEmpty {
      try visitor.visitSingularBytesField(value: self.txTrieRoot, fieldNumber: 2)
    }
    if !self.parentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.parentHash, fieldNumber: 3)
    }
    if self.number != 0 {
      try visitor.visitSingularInt64Field(value: self.number, fieldNumber: 7)
    }
    if self.witnessID != 0 {
      try visitor.visitSingularInt64Field(value: self.witnessID, fieldNumber: 8)
    }
    if !self.witnessAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.witnessAddress, fieldNumber: 9)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_BlockHeader.raw, rhs: Protocol_BlockHeader.raw) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.txTrieRoot != rhs.txTrieRoot {return false}
    if lhs.parentHash != rhs.parentHash {return false}
    if lhs.number != rhs.number {return false}
    if lhs.witnessID != rhs.witnessID {return false}
    if lhs.witnessAddress != rhs.witnessAddress {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Block: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Block"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
    2: .standard(proto: "block_header"),
  ]

  fileprivate class _StorageClass {
    var _transactions: [Protocol_Transaction] = []
    var _blockHeader: Protocol_BlockHeader? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transactions = source._transactions
      _blockHeader = source._blockHeader
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._transactions)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._blockHeader)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._transactions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._transactions, fieldNumber: 1)
      }
      if let v = _storage._blockHeader {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Block, rhs: Protocol_Block) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transactions != rhs_storage._transactions {return false}
        if _storage._blockHeader != rhs_storage._blockHeader {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ChainInventory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChainInventory"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .standard(proto: "remain_num"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.ids)
      case 2: try decoder.decodeSingularInt64Field(value: &self.remainNum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 1)
    }
    if self.remainNum != 0 {
      try visitor.visitSingularInt64Field(value: self.remainNum, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_ChainInventory, rhs: Protocol_ChainInventory) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.remainNum != rhs.remainNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ChainInventory.BlockId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_ChainInventory.protoMessageName + ".BlockId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.hash)
      case 2: try decoder.decodeSingularInt64Field(value: &self.number)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if self.number != 0 {
      try visitor.visitSingularInt64Field(value: self.number, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_ChainInventory.BlockId, rhs: Protocol_ChainInventory.BlockId) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.number != rhs.number {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockInventory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BlockInventory"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.ids)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 1)
    }
    if self.type != .sync {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_BlockInventory, rhs: Protocol_BlockInventory) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockInventory.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SYNC"),
    1: .same(proto: "ADVTISE"),
    2: .same(proto: "FETCH"),
  ]
}

extension Protocol_BlockInventory.BlockId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_BlockInventory.protoMessageName + ".BlockId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.hash)
      case 2: try decoder.decodeSingularInt64Field(value: &self.number)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if self.number != 0 {
      try visitor.visitSingularInt64Field(value: self.number, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_BlockInventory.BlockId, rhs: Protocol_BlockInventory.BlockId) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.number != rhs.number {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Inventory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Inventory"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeRepeatedBytesField(value: &self.ids)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .trx {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Inventory, rhs: Protocol_Inventory) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Inventory.InventoryType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRX"),
    1: .same(proto: "BLOCK"),
  ]
}

extension Protocol_Items: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Items"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "blocks"),
    3: .standard(proto: "block_headers"),
    4: .same(proto: "transactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.blocks)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.blockHeaders)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.transactions)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .err {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 2)
    }
    if !self.blockHeaders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blockHeaders, fieldNumber: 3)
    }
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Items, rhs: Protocol_Items) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.blocks != rhs.blocks {return false}
    if lhs.blockHeaders != rhs.blockHeaders {return false}
    if lhs.transactions != rhs.transactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Items.ItemType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERR"),
    1: .same(proto: "TRX"),
    2: .same(proto: "BLOCK"),
    3: .same(proto: "BLOCKHEADER"),
  ]
}

extension Protocol_DynamicProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DynamicProperties"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_solidity_block_num"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.lastSolidityBlockNum)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lastSolidityBlockNum != 0 {
      try visitor.visitSingularInt64Field(value: self.lastSolidityBlockNum, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_DynamicProperties, rhs: Protocol_DynamicProperties) -> Bool {
    if lhs.lastSolidityBlockNum != rhs.lastSolidityBlockNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_DisconnectMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DisconnectMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.reason)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .requested {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_DisconnectMessage, rhs: Protocol_DisconnectMessage) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_HelloMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HelloMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "version"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "genesisBlockId"),
    5: .same(proto: "solidBlockId"),
    6: .same(proto: "headBlockId"),
  ]

  fileprivate class _StorageClass {
    var _from: Protocol_Endpoint? = nil
    var _version: Int32 = 0
    var _timestamp: Int64 = 0
    var _genesisBlockID: Protocol_HelloMessage.BlockId? = nil
    var _solidBlockID: Protocol_HelloMessage.BlockId? = nil
    var _headBlockID: Protocol_HelloMessage.BlockId? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _from = source._from
      _version = source._version
      _timestamp = source._timestamp
      _genesisBlockID = source._genesisBlockID
      _solidBlockID = source._solidBlockID
      _headBlockID = source._headBlockID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._from)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._version)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._timestamp)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._genesisBlockID)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._solidBlockID)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._headBlockID)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._from {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._version != 0 {
        try visitor.visitSingularInt32Field(value: _storage._version, fieldNumber: 2)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestamp, fieldNumber: 3)
      }
      if let v = _storage._genesisBlockID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._solidBlockID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._headBlockID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_HelloMessage, rhs: Protocol_HelloMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._from != rhs_storage._from {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._genesisBlockID != rhs_storage._genesisBlockID {return false}
        if _storage._solidBlockID != rhs_storage._solidBlockID {return false}
        if _storage._headBlockID != rhs_storage._headBlockID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_HelloMessage.BlockId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_HelloMessage.protoMessageName + ".BlockId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.hash)
      case 2: try decoder.decodeSingularInt64Field(value: &self.number)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if self.number != 0 {
      try visitor.visitSingularInt64Field(value: self.number, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_HelloMessage.BlockId, rhs: Protocol_HelloMessage.BlockId) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.number != rhs.number {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_SmartContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SmartContract"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "origin_address"),
    2: .standard(proto: "contract_address"),
    3: .same(proto: "abi"),
    4: .same(proto: "bytecode"),
    5: .standard(proto: "call_value"),
    6: .standard(proto: "consume_user_resource_percent"),
    7: .same(proto: "name"),
  ]

  fileprivate class _StorageClass {
    var _originAddress: Data = SwiftProtobuf.Internal.emptyData
    var _contractAddress: Data = SwiftProtobuf.Internal.emptyData
    var _abi: Protocol_SmartContract.ABI? = nil
    var _bytecode: Data = SwiftProtobuf.Internal.emptyData
    var _callValue: Int64 = 0
    var _consumeUserResourcePercent: Int64 = 0
    var _name: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _originAddress = source._originAddress
      _contractAddress = source._contractAddress
      _abi = source._abi
      _bytecode = source._bytecode
      _callValue = source._callValue
      _consumeUserResourcePercent = source._consumeUserResourcePercent
      _name = source._name
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._originAddress)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._contractAddress)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._abi)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._bytecode)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._callValue)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._consumeUserResourcePercent)
        case 7: try decoder.decodeSingularStringField(value: &_storage._name)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._originAddress.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._originAddress, fieldNumber: 1)
      }
      if !_storage._contractAddress.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._contractAddress, fieldNumber: 2)
      }
      if let v = _storage._abi {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._bytecode.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._bytecode, fieldNumber: 4)
      }
      if _storage._callValue != 0 {
        try visitor.visitSingularInt64Field(value: _storage._callValue, fieldNumber: 5)
      }
      if _storage._consumeUserResourcePercent != 0 {
        try visitor.visitSingularInt64Field(value: _storage._consumeUserResourcePercent, fieldNumber: 6)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_SmartContract, rhs: Protocol_SmartContract) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._originAddress != rhs_storage._originAddress {return false}
        if _storage._contractAddress != rhs_storage._contractAddress {return false}
        if _storage._abi != rhs_storage._abi {return false}
        if _storage._bytecode != rhs_storage._bytecode {return false}
        if _storage._callValue != rhs_storage._callValue {return false}
        if _storage._consumeUserResourcePercent != rhs_storage._consumeUserResourcePercent {return false}
        if _storage._name != rhs_storage._name {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_SmartContract.ABI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_SmartContract.protoMessageName + ".ABI"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entrys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.entrys)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entrys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entrys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_SmartContract.ABI, rhs: Protocol_SmartContract.ABI) -> Bool {
    if lhs.entrys != rhs.entrys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_SmartContract.ABI.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_SmartContract.ABI.protoMessageName + ".Entry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "anonymous"),
    2: .same(proto: "constant"),
    3: .same(proto: "name"),
    4: .same(proto: "inputs"),
    5: .same(proto: "outputs"),
    6: .same(proto: "type"),
    7: .same(proto: "payable"),
    8: .same(proto: "stateMutability"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.anonymous)
      case 2: try decoder.decodeSingularBoolField(value: &self.constant)
      case 3: try decoder.decodeSingularStringField(value: &self.name)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.inputs)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.outputs)
      case 6: try decoder.decodeSingularEnumField(value: &self.type)
      case 7: try decoder.decodeSingularBoolField(value: &self.payable)
      case 8: try decoder.decodeSingularEnumField(value: &self.stateMutability)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.anonymous != false {
      try visitor.visitSingularBoolField(value: self.anonymous, fieldNumber: 1)
    }
    if self.constant != false {
      try visitor.visitSingularBoolField(value: self.constant, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 4)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 5)
    }
    if self.type != .unknownEntryType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 6)
    }
    if self.payable != false {
      try visitor.visitSingularBoolField(value: self.payable, fieldNumber: 7)
    }
    if self.stateMutability != .unknownMutabilityType {
      try visitor.visitSingularEnumField(value: self.stateMutability, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_SmartContract.ABI.Entry, rhs: Protocol_SmartContract.ABI.Entry) -> Bool {
    if lhs.anonymous != rhs.anonymous {return false}
    if lhs.constant != rhs.constant {return false}
    if lhs.name != rhs.name {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.type != rhs.type {return false}
    if lhs.payable != rhs.payable {return false}
    if lhs.stateMutability != rhs.stateMutability {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_SmartContract.ABI.Entry.EntryType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UnknownEntryType"),
    1: .same(proto: "Constructor"),
    2: .same(proto: "Function"),
    3: .same(proto: "Event"),
    4: .same(proto: "Fallback"),
  ]
}

extension Protocol_SmartContract.ABI.Entry.StateMutabilityType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UnknownMutabilityType"),
    1: .same(proto: "Pure"),
    2: .same(proto: "View"),
    3: .same(proto: "Nonpayable"),
    4: .same(proto: "Payable"),
  ]
}

extension Protocol_SmartContract.ABI.Entry.Param: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_SmartContract.ABI.Entry.protoMessageName + ".Param"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "indexed"),
    2: .same(proto: "name"),
    3: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.indexed)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularStringField(value: &self.type)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.indexed != false {
      try visitor.visitSingularBoolField(value: self.indexed, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_SmartContract.ABI.Entry.Param, rhs: Protocol_SmartContract.ABI.Entry.Param) -> Bool {
    if lhs.indexed != rhs.indexed {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
